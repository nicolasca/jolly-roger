/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useRef, useState } from "react";
import { Trail, useGLTF } from "@react-three/drei";
import { useKeyboardControls } from "./useKeyboardControls";
import { useFrame, extend } from "@react-three/fiber";
import * as THREE from "three"

export default function Model() {
  const group = useRef();
  const [smoothedCameraPosition] = useState(() => new THREE.Vector3(1, 1, 1))
  const [smoothedCameraTarget] = useState(() => new THREE.Vector3())

  const { nodes, materials } = useGLTF("/models/ship.gltf");
  const { left, right, up, down, space } = useKeyboardControls(); // Updated to include space state

  const rotationSpeed = 0.05;
  const shipSpeed = 0.1;

  useFrame((state, delta) => {
    const { clock } = state;

    const rotation = group.current.rotation.y;
    let newRotation = rotation;
    if (down) {
      if (newRotation < Math.PI) {
        newRotation = Math.min(rotation + rotationSpeed, Math.PI);
      } else {
        newRotation = Math.max(rotation - rotationSpeed, Math.PI);
      }
    }
    if (up) {
      if (Math.PI >= rotation > 0) {
        newRotation = Math.max(newRotation - rotationSpeed, 0);
      } else {
        newRotation = Math.max(newRotation + rotationSpeed, 0);
      }
    }
    if (left) {
      if (rotation < Math.PI * 0.5) {
        newRotation = Math.min(newRotation + rotationSpeed, Math.PI * 0.5);
      } else if (rotation <= (Math.PI * 3) / 2) {
        newRotation = Math.max(newRotation - rotationSpeed, Math.PI * 0.5);
      } else {
        newRotation = newRotation + rotationSpeed;
      }
    }
    if (right) {
      if (rotation > Math.PI * 0.5 && (Math.PI * 3) / 2 > rotation) {
        newRotation = Math.min(newRotation + rotationSpeed, (Math.PI * 3) / 2);
      } else if (rotation > (Math.PI * 3) / 2) {
        newRotation = Math.max(newRotation - rotationSpeed, (Math.PI * 3) / 2);
        // Rotation between 0 and 0.5PI
      } else {
        newRotation = newRotation - rotationSpeed;
      }
    }

    // Normalize rotation to stay within -π to π range
    newRotation = (newRotation + 2 * Math.PI) % (2 * Math.PI);

    group.current.rotation.y = newRotation; // Apply rotation

    if (space) {
      // Move forward in the direction the ship is facing, but only if space is pressed
      group.current.position.z -= Math.cos(rotation) * shipSpeed;
      group.current.position.x -= Math.sin(rotation) * shipSpeed;
    }

    const bodyPosition = group.current.position
    const cameraPosition = new THREE.Vector3()
    cameraPosition.copy(bodyPosition)
    cameraPosition.z += 30.25
    cameraPosition.y += 40.65
    cameraPosition.x += -10.65

    const cameraTarget = new THREE.Vector3()
    cameraTarget.copy(bodyPosition)
    cameraTarget.y += 0.25

    smoothedCameraPosition.lerp(cameraPosition, 5 * delta)
    smoothedCameraTarget.lerp(cameraTarget, 5 * delta)

    state.camera.position.copy(smoothedCameraPosition)
    state.camera.lookAt(smoothedCameraTarget)
  });

  return (
    <>
      <Trail
        width={20}
        length={6}
        color={"white"}
        attenuation={(t) => {
          return t * t;
        }}
        target={group}
      />
      <group scale={0.2} castShadow ref={group} dispose={null}>
        <group>
          <mesh
            castShadow
            geometry={nodes.ship_dark_8angles_1.geometry}
            material={nodes.ship_dark_8angles_1.material}
          />
          <mesh
            castShadow
            geometry={nodes.ship_dark_8angles_2.geometry}
            material={materials.woodDark}
          />
          <mesh
            castShadow
            geometry={nodes.ship_dark_8angles_3.geometry}
            material={nodes.ship_dark_8angles_3.material}
          />
          <mesh
            castShadow
            geometry={nodes.ship_dark_8angles_4.geometry}
            material={materials.window}
          />
          <mesh
            castShadow
            geometry={nodes.ship_dark_8angles_5.geometry}
            material={materials["_defaultMat.002"]}
          />
          <group position={[0, 1.44, -3.62]}>
            <mesh
              castShadow
              geometry={nodes.cannon_front_1.geometry}
              material={nodes.cannon_front_1.material}
            />
            <mesh
              castShadow
              geometry={nodes.cannon_front_2.geometry}
              material={nodes.cannon_front_2.material}
            />
            <mesh
              castShadow
              geometry={nodes.cannon_front001.geometry}
              material={nodes.cannon_front001.material}
              position={[0, 0.28, -0.07]}
              rotation={[0.07, 0, 0]}
            />
          </group>
          <group position={[-0.76, 1.28, -1.68]} rotation={[0, Math.PI / 2, 0]}>
            <mesh
              castShadow
              geometry={nodes.cannon_left_1.geometry}
              material={nodes.cannon_left_1.material}
            />
            <mesh
              castShadow
              geometry={nodes.cannon_left_2.geometry}
              material={nodes.cannon_left_2.material}
            />
            <group position={[-0.22, 0.13, 0.26]}>
              <mesh
                castShadow
                geometry={nodes.cannon_left001_1.geometry}
                material={nodes.cannon_left001_1.material}
              />
              <mesh
                castShadow
                geometry={nodes.cannon_left001_2.geometry}
                material={nodes.cannon_left001_2.material}
              />
            </group>
            <group
              position={[0.22, 0.13, 0.26]}
              rotation={[Math.PI, 0, Math.PI]}
            >
              <mesh
                castShadow
                geometry={nodes.cannon_left001_1.geometry}
                material={nodes.cannon_left001_1.material}
              />
              <mesh
                castShadow
                geometry={nodes.cannon_left001_2.geometry}
                material={nodes.cannon_left001_2.material}
              />
            </group>
            <group position={[-0.22, 0.13, -0.2]}>
              <mesh
                castShadow
                geometry={nodes.cannon_left001_1.geometry}
                material={nodes.cannon_left001_1.material}
              />
              <mesh
                castShadow
                geometry={nodes.cannon_left001_2.geometry}
                material={nodes.cannon_left001_2.material}
              />
            </group>
            <group
              position={[0.22, 0.13, -0.2]}
              rotation={[Math.PI, 0, Math.PI]}
            >
              <mesh
                castShadow
                geometry={nodes.cannon_left001_1.geometry}
                material={nodes.cannon_left001_1.material}
              />
              <mesh
                castShadow
                geometry={nodes.cannon_left001_2.geometry}
                material={nodes.cannon_left001_2.material}
              />
            </group>
            <mesh
              castShadow
              geometry={nodes.cannon_left001.geometry}
              material={nodes.cannon_left001.material}
              position={[0, 0.44, -0.07]}
              rotation={[0.09, 0, 0]}
            />
          </group>
          <group position={[0.76, 1.28, -1.68]} rotation={[0, -Math.PI / 2, 0]}>
            <mesh
              castShadow
              geometry={nodes.cannon_left_1.geometry}
              material={nodes.cannon_left_1.material}
            />
            <mesh
              castShadow
              geometry={nodes.cannon_left_2.geometry}
              material={nodes.cannon_left_2.material}
            />
            <group position={[-0.22, 0.13, 0.26]}>
              <mesh
                castShadow
                geometry={nodes.cannon_left001_1.geometry}
                material={nodes.cannon_left001_1.material}
              />
              <mesh
                castShadow
                geometry={nodes.cannon_left001_2.geometry}
                material={nodes.cannon_left001_2.material}
              />
            </group>
            <group
              position={[0.22, 0.13, 0.26]}
              rotation={[Math.PI, 0, Math.PI]}
            >
              <mesh
                castShadow
                geometry={nodes.cannon_left001_1.geometry}
                material={nodes.cannon_left001_1.material}
              />
              <mesh
                castShadow
                geometry={nodes.cannon_left001_2.geometry}
                material={nodes.cannon_left001_2.material}
              />
            </group>
            <group position={[-0.22, 0.13, -0.2]}>
              <mesh
                castShadow
                geometry={nodes.cannon_left001_1.geometry}
                material={nodes.cannon_left001_1.material}
              />
              <mesh
                castShadow
                geometry={nodes.cannon_left001_2.geometry}
                material={nodes.cannon_left001_2.material}
              />
            </group>
            <group
              position={[0.22, 0.13, -0.2]}
              rotation={[Math.PI, 0, Math.PI]}
            >
              <mesh
                castShadow
                geometry={nodes.cannon_left001_1.geometry}
                material={nodes.cannon_left001_1.material}
              />
              <mesh
                castShadow
                geometry={nodes.cannon_left001_2.geometry}
                material={nodes.cannon_left001_2.material}
              />
            </group>
            <mesh
              castShadow
              geometry={nodes.cannon_right001.geometry}
              material={nodes.cannon_right001.material}
              position={[0, 0.44, -0.07]}
              rotation={[0.09, 0, 0]}
            />
          </group>
          <group position={[1.35, 3.03, 1.86]}>
            <mesh
              castShadow
              geometry={nodes.sail_back_1.geometry}
              material={nodes.sail_back_1.material}
            />
            <mesh
              castShadow
              geometry={nodes.sail_back_2.geometry}
              material={nodes.sail_back_2.material}
            />
          </group>
          <group position={[1.35, 1.6, -3.2]}>
            <mesh
              castShadow
              geometry={nodes.sail_front_1.geometry}
              material={nodes.sail_front_1.material}
            />
            <mesh
              castShadow
              geometry={nodes.sail_front_2.geometry}
              material={nodes.sail_front_2.material}
            />
          </group>
          <group position={[1.35, 1.6, -1.55]}>
            <mesh
              castShadow
              geometry={nodes.sail_middle_1.geometry}
              material={nodes.sail_middle_1.material}
            />
            <mesh
              castShadow
              geometry={nodes.sail_middle_2.geometry}
              material={nodes.sail_middle_2.material}
            />
          </group>
          <group position={[0, 2.78, 1.05]}>
            <mesh
              castShadow
              geometry={nodes.steering_1.geometry}
              material={nodes.steering_1.material}
            />
            <mesh
              castShadow
              geometry={nodes.steering_2.geometry}
              material={nodes.steering_2.material}
            />
          </group>
        </group>
      </group>
    </>
  );
}

useGLTF.preload("/models/ship.gltf");
